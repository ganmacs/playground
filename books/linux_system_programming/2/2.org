* 疑問

- fdは一意と言うのはカーネルランドで？ユーザランドで？プロセス空間のスコープで？

一意な番号をカーネルランドのファイルテーブルでもってる。
一つのファイルに対して複数の異なるfdを作ることはできるので、ファイルテーブのキーとしてカーネルランド、ユーザランドで一意そう

- パス名とファイルは違うもの？

パス名はディレクトリが管理している。
ファイルはinodeとその中身が参照しているディスク上のデータってこと？

- 実在しないファイルに対してfdを作れる？


* ファイルを読み書きするにはfdが必要

- オープンしたファイルをプロセスごとに，ファイルテーブルに管理している
- ファイルディスクリプタは fd => メタデータ(inode, ファイルポジション)
- 子プロセスは親プロセスのファイルテーブルにコピーする
- すべてのプロセスは0,1,2は ~stdin~, ~sdtout~ , ~stderr~ に使われる。それぞれマクロが用意されている

* open(fd,flg,mode)

- 渡されたパス名に対応するファイルディスクリプタを作成する
- flagsにモードを渡す
- ~O_CREAT~ わたすと ファイルを作る -> fd作るって流れになってそう

- ファイルのオーナー(O_CREATE)
  - オーナーは作ったプロセスの実効uid
  - groupは実装による
    - プロセスのgidもあるし、親ディレクトリのグループの場合もある

* creat(fd,mode)

- ~open(file,O_WRONLY | O_CREAT | O_TRUNC, 0644)~ と一緒

* read(fd, buf, len)

- fdで示されたファイル内のカレントポジションからlenバイトとってbufにいれる。読み取ったバイト数返す
- 0のときはEOF

- ~戻り値 == len~ : bufに正常に読み取り
- ~0 < 戻り値 < len~ : 戻り値分はコピー成功。読み取り注意シグナル or エラー or EOF到達
- ~0 == 戻り値~ : EOF
- ブロックされる : ブロッキングモードで起動すると
- ~-1 && errno=EINTR~: １バイトも読まなううちにシグナルが飛んできた
- それ以外: 重要なエラー

** ノンブロッキングI/O

- ~read()~ でデータがまだない場合にブロックせずにリターンする
- ~O_NONBLOCK~ フラグをopenに渡すことでこのモードになる
- 準備できていない場合は-1を返す。更に ~EAGAIN~ が ~errno~ に設定されるのでそれを使用して判断する


* write(fd, buf, count)

- bufないのcountバイト数分のでーたを、fdに対応するファイルのカレントポジションに書き込む
- 書き込んだバイト数を返す。-1がエラーで ~errno~ に値をよしなに書き込む
- エラーが発生する以外、中途半端に動くことはめったにない(count数分書き込めないこと)
- appendモードを使用しないと、ファイルポジションについてrace conditionが発生する


** 遅延書き込み

- writeコールをして、カーネルは渡されたバッファの中身を自身のバッファにコピーし、リターンする(実際に書き込む保証はない)
- 実際にファイルにコピーはまとめてパフォーマンスが良くなるように後で実行する

***  pros & cons

pros

- 読み込みはメモリ上の値を返せば良いので早い

cons

- クラッシュすると死ぬ
- 書き込み順序がばらばら (クラッシュ)
- ディスクの物理的な故障とかで死ぬ(遅延で書き込んだタイミングしかわからない)


* 同期I/O

** fsync(fd)

- fdに関連する dirtyバッファ(遅延書き込み用のメモリ上のバッファ) をディスクに書き出す
- 全部書き終わるまでブロックする
- ディスク側のキャッシュにあるかもしれないの(このキャッシュはとても短い時間で書き出されるので気にしなくて良い)


** fdatasync()

- ファイルデータだけでメタデータを書き込む保証はない、早い

両方共directoryについての保証はないので、親ディレクトリに対してもfsyncをする

** sync(void)

- すべてのバッファを書き出す。戻り値はなし

** O_SYNCフラグ

- O_SYNCフラグをopneシステムコールへ渡すと同期的に行われる。
- このフラグがあって、writeシステムコールすると遅延書き込みせずにすぐにかく
- パフォーマンスが悪いのであまりやらないほうが良い(ユーザランド、カーネルランド両方のIO完了をまつので待ち時間が増える)
- O_SYNCつけづにopenして遅延書き込みせずにした後に fsyncしたほうがいいかも

* close(fd)

- ファイルディスクリプタの破棄をする(カーネルでも、アプリケーションでも)
- もし自身が最後にopenしたプロセスだった場合、ファイルのデータを開放する
- 更にほかにファイルに対応するinodeを参照していなければ、inodeも開放


* lseek(fd, po, origin)

- originで挙動を変える。移動後のファイルポジションを返す

* IO多重化

- non-blockingでは 適当なタイミングでsyscallを発行しなければいけない
- 効率が悪い。I/O可能でなければプロセスはスリープするみたいな方が良い

* select()

- timeout or 渡されたfdがio可能になるまでブロックする
